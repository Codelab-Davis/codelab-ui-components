import { Meta, Primary, Controls, Story } from '@storybook/blocks';
import * as ButtonStories from './Button.stories';

<Meta of={ButtonStories} />

# Button

A versatile button component built on top of Radix UI's Slot primitive. It offers an accessible and flexible solution for user interactions, supporting various styles, sizes, and states to meet your design requirements.

## Table of Contents
- [Installation](#installation)
- [Usage](#usage)
- [Props](#props)
- [Variants](#variants)
  - [Primary](#primary)
  - [Secondary](#secondary)
  - [Destructive](#destructive)
  - [Outline](#outline)
  - [Ghost](#ghost)
  - [Link](#link)
- [Sizes](#sizes)
  - [Default](#default)
  - [Small](#small)
  - [Large](#large)
- [Examples](#examples)
  - [As a Link](#as-a-link)
  - [With Icon](#with-icon)
  - [Disabled State](#disabled-state)
- [Best Practices](#best-practices)
- [Accessibility](#accessibility)

---

## Installation

To integrate the Button component into your project, import it from the components directory:

```tsx
import { Button } from "@/components/ui/button";
```

---

## Usage

Using the Button component is straightforward. Hereâ€™s a basic example:

```tsx
<Button>Click me</Button>
```

<Primary />

The example above demonstrates a simple button with the default styling. You can further customize it using the available props and variants.

---

## Props

The Button component accepts a variety of props to control its appearance and behavior. You can explore and modify these properties using the Storybook Controls panel below:

<Controls />

---

## Variants

The Button component includes several pre-defined variants to help you match the design context and action priority. Choose the variant that best communicates the intended action.

### Primary

The default variant, ideal for primary actions.

<Story of={ButtonStories.Primary} />

### Secondary

Use this variant for secondary actions that complement the primary call-to-action.

<Story of={ButtonStories.Secondary} />

### Destructive

Designed for actions that have potentially destructive outcomes, such as deleting data.

<Story of={ButtonStories.Destructive} />

### Outline

A subtle variant featuring only a border, perfect for less prominent actions or alternative styles.

<Story of={ButtonStories.Outline} />

### Ghost

A minimal variant without a background or border, ideal for low-emphasis actions.

<Story of={ButtonStories.Ghost} />

### Link

Styled to resemble a hyperlink while retaining button functionality, useful for inline actions.

<Story of={ButtonStories.Link} />

---

## Sizes

The Button component supports multiple sizes, ensuring it fits well in different interface contexts.

### Default

The standard size for most use cases.

<Story of={ButtonStories.Base} />

### Small

A compact version ideal for use in tight spaces or when a more subtle appearance is needed.

<Story of={ButtonStories.Small} />

### Large

A larger size that emphasizes the action, suitable for prominent calls-to-action.

<Story of={ButtonStories.Large} />

---

## Examples

Here are some practical examples demonstrating various use cases for the Button component.

### As a Link

Render the Button as a link by using the `asChild` prop. This approach is great when integrating with Next.js's `Link` component or an anchor tag:

```tsx
import Link from "next/link";

<Button asChild>
  <Link href="/about">About Page</Link>
</Button>
```

### With Icon

Enhance the button's meaning by combining it with icons. For instance, using an icon from `lucide-react`:

```tsx
import { Mail } from "lucide-react";

<Button>
  <Mail className="mr-2" />
  Login with Email
</Button>
```

### Disabled State

Disable the button when an action is not available, using the `disabled` prop:

```tsx
<Button disabled>
  Please wait...
</Button>
```

---

## Best Practices

When using the Button component, consider these guidelines to ensure a consistent and user-friendly experience:

1. **Variant Selection:** Choose the appropriate variant to clearly communicate the button's importance.
2. **Concise Text:** Keep button labels short and action-oriented.
3. **Icon Usage:** Incorporate icons only when they add clear context to the action.
4. **Consistent Sizing:** Maintain uniform button sizes within the same interface context.
5. **Accessibility:** Ensure that your buttons have sufficient color contrast and clear focus indicators.

---

## Accessibility

The Button component is built with accessibility in mind:

- **Keyboard Navigation:** Fully supports keyboard interactions.
- **Screen Reader Compatibility:** Uses proper ARIA attributes for enhanced accessibility.
- **Focus Management:** Provides visible focus states to aid users navigating via keyboard.
- **Disabled State Styling:** Clearly indicates when the button is inactive.
